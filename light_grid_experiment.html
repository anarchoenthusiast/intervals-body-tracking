<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Grid Audio Experiment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(5px);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid #333;
            z-index: 10;
            align-items: flex-end;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        @keyframes recBlink {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            font-weight: bold;
        }

        input[type="range"] {
            width: 120px;
            height: 4px;
            background: #444;
            border-radius: 2px;
            appearance: none;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="color"] {
            width: 40px;
            height: 25px;
            border: none;
            background: none;
            cursor: pointer;
        }

        button {
            background: #222;
            color: #aaa;
            border: 1px solid #444;
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 4px;
            text-transform: uppercase;
            transition: all 0.2s;
            height: 25px;
        }

        button:hover {
            background: #444;
            color: #fff;
            border-color: #666;
        }

        button.active {
            background: #fff;
            color: #000;
            border-color: #fff;
            font-weight: bold;
        }
        
        button.mute-btn {
            border-color: #f55;
            color: #f55;
        }
        button.mute-btn.active {
            background: #f55;
            color: #fff;
            border-color: #f55;
        }
        
        button.rec-btn {
            border-color: #f33;
            color: #f33;
        }
        button.rec-btn.recording {
            background: #f33;
            color: #fff;
            border-color: #f33;
            animation: recBlink 1s infinite;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            text-align: center;
            transition: opacity 0.5s ease;
        }
        
        h1 {
            font-weight: 300;
            letter-spacing: 4px;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .status-msg {
            color: #666;
            font-size: 12px;
            margin-top: 15px;
        }
        
        #rec-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 50;
        }
        
        #rec-indicator .dot {
            width: 12px;
            height: 12px;
            background: #f33;
            border-radius: 50%;
            animation: recBlink 1s infinite;
        }
        
        #rec-indicator .time {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1>LIGHT AUDIO GRID</h1>
        <button id="start-btn" style="padding: 12px 40px; font-size: 14px; border-radius: 20px;">LAUNCH</button>
        <p class="status-msg" id="status-text">Ready to initialize</p>
    </div>
    
    <div id="rec-indicator">
        <div class="dot"></div>
        <span class="time" id="rec-time">00:00</span>
    </div>

    <div id="export-modal" style="display: none; position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index: 200; flex-direction:column; justify-content:center; align-items:center;">
        <div style="background:#1a1a1a; padding:30px; border-radius:10px; border:1px solid #444; text-align:center; max-width:400px;">
            <h2 style="margin:0 0 20px 0; font-weight:300; letter-spacing:2px;">EXPORT VIDEO</h2>
            <p style="color:#888; font-size:12px; margin-bottom:20px;">
                Frame-by-frame rendering for production quality.<br>
                Each frame synced perfectly with detection.
            </p>
            <div style="display:flex; gap:10px; justify-content:center; margin-bottom:20px;">
                <button id="btn-export-1" style="padding:10px 20px;">ORIGINAL SIZE</button>
                <button id="btn-export-05" style="padding:10px 20px;">0.5x SIZE</button>
            </div>
            
            <div style="margin-bottom:20px;">
                <label style="display:block; margin-bottom:5px;">EXPORT FPS</label>
                <select id="export-fps" style="background:#333; color:white; border:1px solid #555; padding:5px; border-radius:4px; font-family:inherit;">
                    <option value="24">24 FPS (Cinema)</option>
                    <option value="30" selected>30 FPS (Standard)</option>
                    <option value="60">60 FPS (Smooth)</option>
                </select>
            </div>

            <button id="btn-cancel-export" style="margin-top:5px; background:transparent; border:none; color:#666; cursor:pointer;">Cancel</button>
        </div>
    </div>

    <div id="rendering-overlay" style="display: none; position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index: 300; flex-direction:column; justify-content:center; align-items:center;">
        <h2 id="render-status" style="color:#fff; margin-bottom:10px; animation: pulse 1s infinite;">RENDERING FRAMES...</h2>
        <div style="width:300px; height:4px; background:#333; border-radius:2px; overflow:hidden;">
            <div id="render-progress" style="width:0%; height:100%; background:#fff; transition: width 0.1s;"></div>
        </div>
        <p id="render-time" style="color:#888; font-size:12px; margin-top:10px;">Frame 0 / 0</p>
        <button id="btn-cancel-render" style="margin-top:20px; background:#333; border-color:#555;">CANCEL</button>
    </div>

    <div id="canvas-container"></div>

    <div class="controls">
        <div class="control-group">
            <label>App Mode</label>
            <div style="display: flex; gap: 5px;">
                <button id="btn-mode-classic" class="active">CLASSIC</button>
                <button id="btn-mode-ambient">AMBIENT</button>
            </div>
        </div>

        <div class="control-group">
            <label>Threshold (Sens)</label>
            <input type="range" id="threshold-slider" min="50" max="254" value="200">
        </div>
        <div class="control-group">
            <label>Grid Density</label>
            <input type="range" id="grid-slider" min="20" max="100" value="50">
        </div>
        
        <div class="control-group">
            <label>Symbol (Unicode)</label>
            <div style="display: flex; gap: 5px;">
                <input type="text" id="symbol-input" placeholder="" style="width: 40px; background: #222; border: 1px solid #444; color: white; text-align: center; border-radius: 4px; font-family: sans-serif;">
                <input type="range" id="fontsize-slider" min="8" max="64" value="24" style="width: 60px;" title="Font Size">
            </div>
        </div>

        <div class="control-group">
            <label>Dot Settings</label>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="color" id="color-picker" value="#ffffff" title="Dot Color">
                <div style="display:flex; flex-direction:column; gap:2px;">
                    <label style="font-size: 8px;">Alpha</label>
                    <input type="range" id="alpha-slider" min="10" max="255" value="200" style="width: 60px;">
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Trail Effect</label>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="trail-checkbox" style="width:16px; height:16px;">
                <input type="range" id="trail-slider" min="5" max="100" value="30" style="width: 60px;" title="Trail Length">
            </div>
        </div>
        
        <div class="control-group">
            <label>Volume</label>
            <input type="range" id="volume-slider" min="0" max="100" value="80">
        </div>

        <div class="control-group">
            <label>Source</label>
            <div style="display: flex; gap: 5px;">
                <button id="btn-cam" class="active">CAM</button>
                <button id="btn-rec" class="rec-btn">REC</button>
                <button id="btn-video">FILE</button>
            </div>
            <input type="file" id="video-upload" accept="video/*" style="display: none;">
        </div>

        <div class="control-group">
            <label>Export</label>
            <button id="btn-open-export">RENDER</button>
        </div>

        <div class="control-group" style="justify-content: flex-end;">
             <button id="btn-mute" class="mute-btn">MUTE</button>
        </div>
    </div>

    <script>
        let video;
        let gridSize = 50;
        let threshold = 200;
        let gridColor = '#ffffff';
        let gridAlpha = 200;
        let activeSymbol = '';
        let symbolFontSize = 24;
        
        // Trail effect
        let trailEnabled = false;
        let trailLength = 30;
        let trailBuffer;
        
        let cells = [];
        let isAudioStarted = false;
        let isMuted = false;
        let videoMode = 'camera'; 
        let appMode = 'classic';
        
        // Live Recording
        let isLiveRecording = false;
        let liveRecorder;
        let liveRecordedChunks = [];
        let liveRecordStartTime = 0;
        let liveRecordTimer = null;
        
        // Frame-by-frame Export
        let isExporting = false;
        let exportCanceled = false;
        let exportFPS = 30;
        let originalGridSize = 50;
        let originalWidth, originalHeight;
        let mediaRecorder;
        let recordedChunks = [];
        let canvasStream;
        let videoTrack;
        let exportStreamDest;
        
        const numVoices = 16;
        let voices = [];
        let voiceIndex = 0;
        let reverb;

        const notesScale = [
            196.00, 220.00, 261.63, 293.66, 329.63, 392.00,
            440.00, 523.25, 587.33, 659.25, 783.99,
            880.00, 1046.50, 1174.66, 1318.51
        ];

        class Voice {
            constructor() {
                this.osc = new p5.Oscillator('sine');
                this.env = new p5.Envelope();
                this.env.setADSR(0.02, 0.1, 0.3, 1.0); 
                this.env.setRange(0.25, 0); 
                
                this.filter = new p5.LowPass();
                this.filter.freq(2000);
                
                this.osc.disconnect();
                this.osc.connect(this.filter);
                this.osc.amp(this.env);
                this.osc.start();
            }

            play(freq, xPos, yPos, mode = 'classic') {
                if (isMuted) return;
                
                const waves = ['sine', 'sine', 'triangle', 'sine'];
                this.osc.setType(random(waves));

                let panVal = map(xPos, 0, width, -1, 1);
                this.osc.pan(panVal);

                let fFreq = map(yPos, height, 0, 500, 5000);
                this.filter.freq(fFreq + random(-200, 200));

                if (mode === 'ambient') {
                    let attack = random(2.0, 4.0);
                    let release = random(6.0, 12.0);
                    this.env.setADSR(attack, 1.0, 0.4, release);
                    this.env.setRange(random(0.1, 0.2), 0);
                } else {
                    let release = random(0.5, 2.5);
                    this.env.setADSR(0.02, 0.1, 0.3, release);
                    this.env.setRange(random(0.15, 0.3), 0);
                }

                let detune = random(-2, 2); 
                this.osc.freq(freq + detune);
                this.env.play();
            }
        }

        function setup() {
            const canvas = createCanvas(windowWidth, windowHeight);
            pixelDensity(1); 
            canvas.parent('canvas-container');
            
            trailBuffer = createGraphics(windowWidth, windowHeight);
            trailBuffer.pixelDensity(1);
            trailBuffer.background(0);
            
            getAudioContext().suspend();
            initCamera();
            setupUI();
            initGrid();
        }
        
        // ============ FRAME-BY-FRAME EXPORT ============
        
        async function startFrameByFrameExport(scaleFactor) {
            if (!video || !video.elt) return;
            if (!isAudioStarted) {
                alert("Please LAUNCH the experiment first.");
                return;
            }

            exportFPS = parseInt(document.getElementById('export-fps').value);
            console.log(`Starting frame-by-frame export at ${exportFPS} FPS...`);
            
            // Store original state
            originalGridSize = gridSize;
            originalWidth = width;
            originalHeight = height;
            
            // Calculate export dimensions
            let exportW = floor(video.width * scaleFactor);
            let exportH = floor(video.height * scaleFactor);
            exportW = exportW % 2 === 0 ? exportW : exportW + 1;
            exportH = exportH % 2 === 0 ? exportH : exportH + 1;
            
            // Scale grid
            const scaleRatio = exportW / originalWidth;
            gridSize = gridSize * scaleRatio;
            
            // Resize canvas
            resizeCanvas(exportW, exportH);
            trailBuffer = createGraphics(exportW, exportH);
            trailBuffer.pixelDensity(1);
            trailBuffer.background(0);
            initGrid();
            
            // Setup recording
            isExporting = true;
            exportCanceled = false;
            recordedChunks = [];
            
            // Create canvas stream with manual frame capture (0 = request frames manually)
            canvasStream = document.querySelector('canvas').captureStream(0);
            videoTrack = canvasStream.getVideoTracks()[0];
            
            // Add audio if available
            let combinedTracks = [videoTrack];
            if (exportStreamDest && exportStreamDest.stream) {
                exportStreamDest.stream.getAudioTracks().forEach(t => combinedTracks.push(t));
            }
            
            const combinedStream = new MediaStream(combinedTracks);
            
            const options = { 
                mimeType: 'video/webm; codecs=vp9,opus',
                videoBitsPerSecond: 15000000 // 15 Mbps
            };
            
            try {
                mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                mediaRecorder = new MediaRecorder(combinedStream);
            }
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) recordedChunks.push(event.data);
            };
            
            // Show UI
            document.getElementById('rendering-overlay').style.display = 'flex';
            document.querySelector('.controls').style.display = 'none';
            document.getElementById('render-status').innerText = 'RENDERING FRAMES...';
            
            // Calculate total frames
            const duration = video.duration();
            const totalFrames = Math.ceil(duration * exportFPS);
            
            // Pause video, we control time manually
            video.pause();
            video.time(0);
            
            // Start MediaRecorder
            mediaRecorder.start();
            
            // Wait a moment for recorder to initialize
            await sleep(200);
            
            const startTime = performance.now();
            
            // Render each frame
            for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
                if (exportCanceled) break;
                
                // Set video time for this frame
                const frameTime = frameIndex / exportFPS;
                video.time(frameTime);
                
                // Wait for video to seek to the exact frame
                await waitForSeek(video.elt, frameTime);
                
                // Render this frame
                renderSingleFrame();
                
                // Request frame capture from MediaRecorder
                if (videoTrack.requestFrame) {
                    videoTrack.requestFrame();
                }
                
                // Update progress UI
                const progress = ((frameIndex + 1) / totalFrames) * 100;
                document.getElementById('render-progress').style.width = progress + '%';
                
                const elapsed = (performance.now() - startTime) / 1000;
                const fps = (frameIndex + 1) / elapsed;
                const remaining = Math.ceil((totalFrames - frameIndex - 1) / fps);
                
                document.getElementById('render-time').innerText = 
                    `Frame ${frameIndex + 1} / ${totalFrames} | ${fps.toFixed(1)} fps | ~${remaining}s left`;
                
                // Minimal delay for frame capture
                await sleep(16);
            }
            
            // Stop recording
            if (!exportCanceled) {
                document.getElementById('render-status').innerText = 'FINALIZING...';
            }
            
            mediaRecorder.stop();
            
            // Wait for mediaRecorder to finish
            await new Promise(resolve => {
                mediaRecorder.onstop = resolve;
            });
            
            // Finish export
            finishFrameExport();
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function waitForSeek(videoElement, targetTime) {
            return new Promise(resolve => {
                // If video is already at the target time (within tolerance), resolve immediately
                if (Math.abs(videoElement.currentTime - targetTime) < 0.02) {
                    // Minimal wait for frame decode
                    setTimeout(resolve, 10);
                    return;
                }
                
                const onSeeked = () => {
                    videoElement.removeEventListener('seeked', onSeeked);
                    // Minimal delay after seek
                    setTimeout(resolve, 5);
                };
                
                videoElement.addEventListener('seeked', onSeeked);
                
                // Fallback timeout in case seeked doesn't fire
                setTimeout(() => {
                    videoElement.removeEventListener('seeked', onSeeked);
                    resolve();
                }, 100);
            });
        }
        
        function renderSingleFrame() {
            // Trail effect
            if (trailEnabled) {
                trailBuffer.noStroke();
                trailBuffer.fill(0, trailLength);
                trailBuffer.rect(0, 0, trailBuffer.width, trailBuffer.height);
            } else {
                background(0);
            }
            
            if (video && video.loadedmetadata) {
                // Set draw params for export size
                video.drawParams = { w: width, h: height };
                
                // Draw video
                if (trailEnabled) {
                    trailBuffer.push();
                    trailBuffer.imageMode(CORNER);
                    trailBuffer.image(video, 0, 0, width, height);
                    trailBuffer.pop();
                } else {
                    push();
                    imageMode(CORNER);
                    image(video, 0, 0, width, height);
                    pop();
                }
                
                // Load pixels for light detection
                video.loadPixels();
                if (video.pixels.length > 0) {
                    processLightForExport();
                }
            }
            
            // Draw trail buffer if enabled
            if (trailEnabled) {
                image(trailBuffer, 0, 0);
            }
            
            // Draw grid
            drawGridForExport();
        }
        
        function processLightForExport() {
            if (!video.pixels.length || !video.drawParams) return;

            const scaleX = video.width / video.drawParams.w;
            const scaleY = video.height / video.drawParams.h;

            cells.forEach(cell => {
                let vidX = floor(cell.x * scaleX);
                let vidY = floor(cell.y * scaleY);

                vidX = constrain(vidX, 0, video.width - 1);
                vidY = constrain(vidY, 0, video.height - 1);

                const index = (vidY * video.width + vidX) * 4;
                
                if (index < 0 || index >= video.pixels.length) return;

                const r = video.pixels[index];
                const g = video.pixels[index + 1];
                const b = video.pixels[index + 2];
                const bright = (r * 0.299 + g * 0.587 + b * 0.114);

                if (bright > threshold) {
                    if (appMode === 'ambient') {
                        cell.energy += 0.02;
                        if (cell.energy >= 1.0) {
                            cell.active = true;
                            cell.cooldown = 120;
                            cell.energy = 0;
                            if (activeSymbol && activeSymbol.length > 0) {
                                const chars = Array.from(activeSymbol);
                                cell.pickedChar = chars[floor(random(chars.length))];
                            }
                            triggerSound(cell.noteFreq, cell.x, cell.y);
                        }
                    } else {
                        if (cell.cooldown <= 0) {
                            cell.active = true;
                            cell.cooldown = 30;
                            if (activeSymbol && activeSymbol.length > 0) {
                                const chars = Array.from(activeSymbol);
                                cell.pickedChar = chars[floor(random(chars.length))];
                            }
                            triggerSound(cell.noteFreq, cell.x, cell.y);
                        }
                    }
                } else {
                    cell.active = false;
                    if (appMode === 'ambient') cell.energy = max(0, cell.energy - 0.005);
                }

                if (cell.cooldown > 0) cell.cooldown--;
            });
        }
        
        function drawGridForExport() {
            noStroke();
            rectMode(CENTER);
            textAlign(CENTER, CENTER);
            
            let baseColor = color(gridColor);
            let dotSize = max(2, gridSize * 0.06);
            let activeDotSize = dotSize * 2;

            cells.forEach(cell => {
                if (cell.active || cell.cooldown > 20) {
                    baseColor.setAlpha(255);
                    fill(baseColor);

                    if (activeSymbol) {
                        drawingContext.shadowBlur = 15;
                        drawingContext.shadowColor = gridColor;
                        
                        let fs = symbolFontSize * (width / (originalWidth || windowWidth));
                        textSize(fs);
                        
                        let charToShow = activeSymbol;
                        if (Array.from(activeSymbol).length > 1) {
                            charToShow = cell.pickedChar || Array.from(activeSymbol)[0];
                        }

                        text(charToShow, cell.x, cell.y);
                        drawingContext.shadowBlur = 0;
                        
                        if (trailEnabled) {
                            trailBuffer.fill(baseColor);
                            trailBuffer.noStroke();
                            trailBuffer.textAlign(CENTER, CENTER);
                            trailBuffer.textSize(fs);
                            trailBuffer.text(charToShow, cell.x, cell.y);
                        }
                    } else {
                        ellipse(cell.x, cell.y, dotSize, dotSize);
                        drawingContext.shadowBlur = 15;
                        drawingContext.shadowColor = gridColor;
                        ellipse(cell.x, cell.y, activeDotSize, activeDotSize); 
                        drawingContext.shadowBlur = 0; 
                        
                        if (trailEnabled) {
                            trailBuffer.fill(baseColor);
                            trailBuffer.noStroke();
                            trailBuffer.ellipse(cell.x, cell.y, activeDotSize, activeDotSize);
                        }
                    }
                } else {
                    baseColor.setAlpha(gridAlpha);
                    fill(baseColor);
                    ellipse(cell.x, cell.y, dotSize, dotSize);
                }
            });
        }
        
        function finishFrameExport() {
            isExporting = false;
            
            if (!exportCanceled && recordedChunks.length > 0) {
                // Create and download video
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                document.body.appendChild(a);
                a.style.display = 'none';
                a.href = url;
                a.download = 'light_grid_export.webm';
                a.click();
                window.URL.revokeObjectURL(url);
            }
            
            // Restore state
            gridSize = originalGridSize;
            resizeCanvas(originalWidth, originalHeight);
            trailBuffer = createGraphics(originalWidth, originalHeight);
            trailBuffer.pixelDensity(1);
            trailBuffer.background(0);
            initGrid();
            
            // Restore UI
            document.getElementById('rendering-overlay').style.display = 'none';
            document.querySelector('.controls').style.display = 'flex';
            
            // Reset video
            video.loop();
        }
        
        // ============ LIVE RECORDING ============
        
        function startLiveRecording() {
            if (!video || !video.elt || !video.elt.srcObject) {
                alert("Camera not ready. Please wait.");
                return;
            }
            
            isLiveRecording = true;
            liveRecordedChunks = [];
            
            const cameraStream = video.elt.srcObject;
            
            let combinedTracks = [];
            cameraStream.getVideoTracks().forEach(t => combinedTracks.push(t));
            
            if (exportStreamDest && exportStreamDest.stream) {
                exportStreamDest.stream.getAudioTracks().forEach(t => combinedTracks.push(t));
            }
            
            const combinedStream = new MediaStream(combinedTracks);
            
            const options = { 
                mimeType: 'video/webm; codecs=vp9,opus',
                videoBitsPerSecond: 8000000
            };
            
            try {
                liveRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                liveRecorder = new MediaRecorder(combinedStream);
            }
            
            liveRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) liveRecordedChunks.push(event.data);
            };
            
            liveRecorder.onstop = finishLiveRecording;
            
            liveRecorder.start();
            liveRecordStartTime = Date.now();
            
            document.getElementById('rec-indicator').style.display = 'flex';
            document.getElementById('btn-rec').classList.add('recording');
            document.getElementById('btn-rec').innerText = 'STOP';
            
            liveRecordTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - liveRecordStartTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('rec-time').innerText = `${mins}:${secs}`;
            }, 1000);
            
            console.log("Live recording started");
        }
        
        function stopLiveRecording() {
            if (liveRecorder && liveRecorder.state === 'recording') {
                liveRecorder.stop();
            }
            
            clearInterval(liveRecordTimer);
            document.getElementById('rec-indicator').style.display = 'none';
            document.getElementById('btn-rec').classList.remove('recording');
            document.getElementById('btn-rec').innerText = 'REC';
        }
        
        function finishLiveRecording() {
            isLiveRecording = false;
            
            if (liveRecordedChunks.length === 0) {
                console.log("No data recorded");
                return;
            }
            
            const blob = new Blob(liveRecordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            
            videoMode = 'file';
            toggleButtons();
            
            if (video) {
                video.stop();
                video.remove();
            }
            
            video = createVideo(url, () => {
                video.loop();
                video.volume(0);
                video.hide();
                console.log("Live recording loaded as video file. Ready for export.");
            });
            
            trailBuffer.background(0);
        }

        function windowResized() {
            if (isExporting) return;
            resizeCanvas(windowWidth, windowHeight);
            
            trailBuffer = createGraphics(windowWidth, windowHeight);
            trailBuffer.pixelDensity(1);
            trailBuffer.background(0);
            
            if (videoMode === 'camera') {
                initCamera(); 
            }
            initGrid();
        }

        function setupAudio() {
            let ac = getAudioContext();
            reverb = new p5.Reverb();
            reverb.set(5, 2); 

            exportStreamDest = ac.createMediaStreamDestination();

            for (let i = 0; i < numVoices; i++) {
                let v = new Voice();
                v.filter.disconnect();
                v.filter.connect(reverb);
                voices.push(v);
            }
            reverb.connect(); 
            reverb.output.connect(exportStreamDest); 
        }

        function setupUI() {
            document.getElementById('threshold-slider').addEventListener('input', (e) => {
                threshold = parseInt(e.target.value);
            });

            document.getElementById('grid-slider').addEventListener('input', (e) => {
                gridSize = parseInt(e.target.value);
                initGrid();
            });

            document.getElementById('color-picker').addEventListener('input', (e) => {
                gridColor = e.target.value;
            });
            
            document.getElementById('alpha-slider').addEventListener('input', (e) => {
                gridAlpha = parseInt(e.target.value);
            });

            document.getElementById('symbol-input').addEventListener('input', (e) => {
                activeSymbol = e.target.value;
            });
            
            document.getElementById('fontsize-slider').addEventListener('input', (e) => {
                symbolFontSize = parseInt(e.target.value);
            });
            
            document.getElementById('trail-checkbox').addEventListener('change', (e) => {
                trailEnabled = e.target.checked;
                if (!trailEnabled) {
                    trailBuffer.background(0);
                }
            });
            
            document.getElementById('trail-slider').addEventListener('input', (e) => {
                trailLength = parseInt(e.target.value);
            });

            const muteBtn = document.getElementById('btn-mute');
            muteBtn.addEventListener('click', () => {
                isMuted = !isMuted;
                muteBtn.classList.toggle('active', isMuted);
                muteBtn.innerText = isMuted ? "UNMUTE" : "MUTE";
                if (isMuted) outputVolume(0, 0.1);
                else {
                    const vol = document.getElementById('volume-slider').value / 100;
                    outputVolume(vol, 0.1);
                }
            });

            document.getElementById('volume-slider').addEventListener('input', (e) => {
                if (!isMuted) {
                    outputVolume(e.target.value / 100, 0.1);
                }
            });

            document.getElementById('start-btn').addEventListener('click', () => {
                document.getElementById('status-text').innerText = "Initializing systems...";
                userStartAudio().then(() => {
                    setupAudio();
                    isAudioStarted = true;
                    document.getElementById('start-overlay').style.opacity = '0';
                    setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
                }).catch(e => {
                    document.getElementById('status-text').innerText = "Audio Error: " + e;
                });
            });

            const exportModal = document.getElementById('export-modal');
            
            document.getElementById('btn-open-export').addEventListener('click', () => {
                if (videoMode !== 'file') {
                    alert("Please upload a video file or record from camera first.");
                    return;
                }
                exportModal.style.display = 'flex';
            });

            document.getElementById('btn-cancel-export').addEventListener('click', () => {
                exportModal.style.display = 'none';
            });

            document.getElementById('btn-export-1').addEventListener('click', () => {
                startFrameByFrameExport(1.0);
                exportModal.style.display = 'none';
            });

            document.getElementById('btn-export-05').addEventListener('click', () => {
                startFrameByFrameExport(0.5);
                exportModal.style.display = 'none';
            });
            
            document.getElementById('btn-cancel-render').addEventListener('click', () => {
                exportCanceled = true;
            });

            const btnClassic = document.getElementById('btn-mode-classic');
            const btnAmbient = document.getElementById('btn-mode-ambient');

            btnClassic.addEventListener('click', () => {
                appMode = 'classic';
                btnClassic.classList.add('active');
                btnAmbient.classList.remove('active');
            });

            btnAmbient.addEventListener('click', () => {
                appMode = 'ambient';
                btnAmbient.classList.add('active');
                btnClassic.classList.remove('active');
            });

            document.getElementById('btn-cam').addEventListener('click', () => {
                if (isLiveRecording) {
                    stopLiveRecording();
                }
                videoMode = 'camera';
                toggleButtons();
                initCamera();
                trailBuffer.background(0);
            });
            
            document.getElementById('btn-rec').addEventListener('click', () => {
                if (!isAudioStarted) {
                    alert("Please LAUNCH the experiment first.");
                    return;
                }
                
                if (videoMode !== 'camera') {
                    alert("Switch to CAM mode first to record.");
                    return;
                }
                
                if (isLiveRecording) {
                    stopLiveRecording();
                } else {
                    startLiveRecording();
                }
            });

            document.getElementById('btn-video').addEventListener('click', () => {
                if (isLiveRecording) {
                    stopLiveRecording();
                }
                document.getElementById('video-upload').click();
            });

            document.getElementById('video-upload').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    videoMode = 'file';
                    toggleButtons();
                    const file = e.target.files[0];
                    const url = URL.createObjectURL(file);
                    
                    if (video) {
                        video.stop();
                        video.remove();
                    }
                    video = createVideo(url, () => {
                        video.loop();
                        video.volume(0);
                        video.hide();
                    });
                    trailBuffer.background(0);
                }
            });
        }

        function initCamera() {
            if (video) {
                video.stop();
                video.remove();
            }
            video = createCapture({
                audio: false,
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            video.hide();
        }

        function toggleButtons() {
            document.getElementById('btn-cam').classList.toggle('active', videoMode === 'camera');
            document.getElementById('btn-video').classList.toggle('active', videoMode === 'file');
        }

        function initGrid() {
            cells = [];
            const cols = floor(width / gridSize);
            const rows = floor(height / gridSize);
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const noteIndex = floor(map(rows - y, 0, rows, 0, notesScale.length - 1));
                    cells.push({
                        x: x * gridSize + gridSize/2,
                        y: y * gridSize + gridSize/2,
                        active: false,
                        energy: 0,
                        cooldown: 0,
                        noteFreq: notesScale[noteIndex % notesScale.length]
                    });
                }
            }
        }

        function draw() {
            // Skip normal draw during export
            if (isExporting) return;
            
            // Trail effect
            if (trailEnabled) {
                trailBuffer.noStroke();
                trailBuffer.fill(0, trailLength);
                trailBuffer.rect(0, 0, trailBuffer.width, trailBuffer.height);
            } else {
                background(0);
            }
            
            if (video && video.loadedmetadata) {
                let vidRatio = video.width / video.height;
                let screenRatio = width / height;
                let drawW, drawH;

                if (vidRatio > screenRatio) {
                    drawH = height;
                    drawW = height * vidRatio;
                } else {
                    drawW = width;
                    drawH = width / vidRatio;
                }

                video.drawParams = { w: drawW, h: drawH };

                if (trailEnabled) {
                    trailBuffer.push();
                    trailBuffer.imageMode(CENTER);
                    if (videoMode === 'camera') {
                        trailBuffer.translate(width, 0);
                        trailBuffer.scale(-1, 1);
                        trailBuffer.image(video, width/2, height/2, drawW, drawH);
                    } else {
                        trailBuffer.image(video, width/2, height/2, drawW, drawH);
                    }
                    trailBuffer.pop();
                } else {
                    push();
                    imageMode(CENTER);
                    if (videoMode === 'camera') {
                        translate(width, 0);
                        scale(-1, 1);
                        image(video, width/2, height/2, drawW, drawH);
                    } else {
                        image(video, width/2, height/2, drawW, drawH);
                    }
                    pop();
                }

                video.loadPixels();
                if (video.pixels.length > 0) {
                    processLight();
                }
            }

            if (trailEnabled) {
                image(trailBuffer, 0, 0);
            }

            drawGrid();
        }

        function processLight() {
            if (!video.pixels.length || !video.drawParams) return;

            let offX = (width - video.drawParams.w) / 2;
            let offY = (height - video.drawParams.h) / 2;

            const scaleX = video.width / video.drawParams.w;
            const scaleY = video.height / video.drawParams.h;

            cells.forEach(cell => {
                let displayX = cell.x;
                let displayY = cell.y;

                if (videoMode === 'camera') {
                    displayX = width - displayX;
                }

                let relX = displayX - offX;
                let relY = displayY - offY;

                if (relX < 0 || relX >= video.drawParams.w || relY < 0 || relY >= video.drawParams.h) {
                    cell.active = false;
                    return;
                }

                let vidX = floor(relX * scaleX);
                let vidY = floor(relY * scaleY);

                vidX = constrain(vidX, 0, video.width - 1);
                vidY = constrain(vidY, 0, video.height - 1);

                const index = (vidY * video.width + vidX) * 4;
                
                if (index < 0 || index >= video.pixels.length) return;

                const r = video.pixels[index];
                const g = video.pixels[index + 1];
                const b = video.pixels[index + 2];
                const bright = (r * 0.299 + g * 0.587 + b * 0.114);

                if (bright > threshold) {
                    if (appMode === 'ambient') {
                        cell.energy += 0.02;
                        if (cell.energy >= 1.0) {
                            cell.active = true;
                            cell.cooldown = 120;
                            cell.energy = 0;
                            
                            if (activeSymbol && activeSymbol.length > 0) {
                                const chars = Array.from(activeSymbol);
                                cell.pickedChar = chars[floor(random(chars.length))];
                            }
                            triggerSound(cell.noteFreq, cell.x, cell.y);
                        }
                    } else {
                        if (cell.cooldown <= 0) {
                            cell.active = true;
                            cell.cooldown = 30; 
                            if (activeSymbol && activeSymbol.length > 0) {
                                const chars = Array.from(activeSymbol);
                                cell.pickedChar = chars[floor(random(chars.length))];
                            }
                            triggerSound(cell.noteFreq, cell.x, cell.y); 
                        }
                    }
                } else {
                    cell.active = false;
                    if (appMode === 'ambient') cell.energy = max(0, cell.energy - 0.005);
                }

                if (cell.cooldown > 0) cell.cooldown--;
            });
        }

        function triggerSound(freq, xPos, yPos) {
            if (!isAudioStarted || isMuted) return;
            
            const voice = voices[voiceIndex];
            
            let octJumpProb = (appMode === 'ambient') ? 0.9 : 0.8;
            if (random() > octJumpProb) {
                freq *= (random() > 0.5 ? 2 : 0.5);
            }

            voice.play(freq, xPos, yPos, appMode);
            voiceIndex = (voiceIndex + 1) % numVoices;
        }

        function drawGrid() {
            noStroke();
            rectMode(CENTER);
            textAlign(CENTER, CENTER);
            
            let baseColor = color(gridColor);
            let dotSize = max(2, gridSize * 0.06);
            let activeDotSize = dotSize * 2;

            cells.forEach(cell => {
                if (cell.active || cell.cooldown > 20) {
                    baseColor.setAlpha(255);
                    fill(baseColor);

                    if (activeSymbol) {
                        drawingContext.shadowBlur = 15;
                        drawingContext.shadowColor = gridColor;
                        textSize(symbolFontSize);
                        
                        let charToShow = activeSymbol;
                        if (Array.from(activeSymbol).length > 1) {
                            charToShow = cell.pickedChar || Array.from(activeSymbol)[0];
                        }

                        text(charToShow, cell.x, cell.y);
                        drawingContext.shadowBlur = 0;
                        
                        if (trailEnabled) {
                            trailBuffer.fill(baseColor);
                            trailBuffer.noStroke();
                            trailBuffer.textAlign(CENTER, CENTER);
                            trailBuffer.textSize(symbolFontSize);
                            trailBuffer.text(charToShow, cell.x, cell.y);
                        }
                    } else {
                        ellipse(cell.x, cell.y, dotSize, dotSize);
                        drawingContext.shadowBlur = 15;
                        drawingContext.shadowColor = gridColor;
                        ellipse(cell.x, cell.y, activeDotSize, activeDotSize); 
                        drawingContext.shadowBlur = 0; 
                        
                        if (trailEnabled) {
                            trailBuffer.fill(baseColor);
                            trailBuffer.noStroke();
                            trailBuffer.ellipse(cell.x, cell.y, activeDotSize, activeDotSize);
                        }
                    }
                } else {
                    baseColor.setAlpha(gridAlpha);
                    fill(baseColor);
                    ellipse(cell.x, cell.y, dotSize, dotSize);
                }
            });
        }
    </script>
</body>
</html>
